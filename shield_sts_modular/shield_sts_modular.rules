OVERCLOCK
{
	ARC_RADIUS_FACTOR = 150%
	HEAT_PER_SECOND = 30 // x4, use 15 if using the second ring
	HEAT_PER_DAMAGE = 0.25
}
HEAT_TO_RESOURCE = &<./Data/statuses/heat/heat.rules>/STATUS_TO_RESOURCE_RATIO
HEAT_TO_STATUS = &<./Data/statuses/heat/heat.rules>/RESOURCE_TO_STATUS_RATIO

Part : <./Data/ships/terran/base_part_terran_overclock.rules>/Part
{
	NameKey = "Parts/KebechetSTSmodularShield"
	IconNameKey = "Parts/KebechetSTSmodularShieldIcon"
	DescriptionKey = "Parts/KebechetSTSmodularShieldDesc"
	ID = swefpifh.Kebechet_STS_modularShield
	EditorGroup = "Defenses"
	Resources
	[
		[steel, 20]
		[coil2, 20]
	]
	AIValueFactor = 5
	Size = [2, 2]
	PhysicalRect = [0, 0, 2, 2] // For backwards compatibility with old shield generators.
	SaveRect = &PhysicalRect
	SelectionPriority = 1
	SelectionTypeID = "shield_gen_sts"
	SelectionTypeByRotation = false
	MaxHealth = 5000
	TypeCategories = [defense, uses_power]
	ReceivableBuffs : ^/0/ReceivableBuffs [BubbleResistanceBonus, BubbleRadiusBonus]
	PenetrationRectType = Normal
	// ExplosiveDamageAbsorption = 50%
	IsRotateable = false
	IgnoreRotationForMirroredSelection = true
	IsFlippable = false

	EditorIcon
	{
		Texture
		{
			File = "icon.png"
			SampleMode = Linear
		}
		Size = [64, 64]
	}
	Components : ^/0/Components, <purple/purple.rules>/Components, <blue/blue.rules>/Components, <green/green.rules>/Components, <orange/orange.rules>/Components, <red/red.rules>/Components, <yellow/yellow.rules>/Components
	{

		// --------------------------------- START TOGGLES
		
		// -----------------------------------------------
		// COLOURS TOGGLES -------------------------------
		// -----------------------------------------------

		ToggleColours
		{
			Type = UIToggle
			ToggleID = "Kebechet_ToggleID_Colours"
			Default = 0
			AlwaysAllowInBuildMode = true
			RequiresCommand = false
		}
		
		ToggleColours_Purple
		{
			Type = ModeToggle
			Mode = ToggleColours
			OnMode = 0
		}
		ToggleColours_Blue :	ToggleColours_Purple	{ OnMode = 1 }
		ToggleColours_Orange :	ToggleColours_Purple	{ OnMode = 2 }
		ToggleColours_Red :		ToggleColours_Purple	{ OnMode = 3 }
		ToggleColours_Yellow :	ToggleColours_Purple	{ OnMode = 4 }
		ToggleColours_Green :	ToggleColours_Purple	{ OnMode = 5 }

		// -----------------------------------------------
		// DISPLAY TOGGLES -------------------------------
		// -----------------------------------------------
		
		ToggleDisplay
		{
			Type = UIToggle
			ToggleID = "Kebechet_ToggleID_Display"
			Default = 0
			AlwaysAllowInBuildMode = true
			RequiresCommand = false
		}

		ToggleDisplay_On
		{
			Type = ModeToggle
			Mode = ToggleDisplay
			OnMode = 0
		}

		ToggleDisplay_Off : ToggleDisplay_On	{ OnMode = 1 }
		
		// -----------------------------------------------
		// PROXY -----------------------------------------
		// -----------------------------------------------
		
		ColoursProxy
		{
			Type = ToggleProxy
			ComponentID = ColoursSet
		}
		ColoursSet
		{
			Type = MultiToggle
			Toggles = [ToggleColours_Purple, ToggleColours_Blue, ToggleColours_Orange, ToggleColours_Red, ToggleColours_Yellow, ToggleColours_Green]
			Mode = Any
		}

		DisplayProxy
		{
			Type = ToggleProxy
			ComponentID = DisplaySet
		}
		DisplaySet
		{
			Type = MultiToggle
			Toggles = [ToggleDisplay_Off, ToggleDisplay_On]
			Mode = Any
		}

		// --------------------------------- END TOGGLES
		
		IsOperational
		{
			Type = MultiToggle
			Toggles = [PowerToggle, BatteryStorage, ScorchedToggle, &~/Part/^/0/OVERCLOCK_OPERATIONAL] // ModularCombinedBatteryStorage // CombinedBatteryStorage
			Mode = All
		}
		
		IsOperationalNonOverclocked
		{
			Type = MultiToggle
			Toggles = [ IsOperational, { Toggle=IsOverclocked; Invert=true } ]
			Mode = All
		}

		IsNonOverclocked
		{
			Type = MultiToggle
			Toggles = [IsOverclocked]
			Invert = true
			Mode = All
		}
		IsNonOverclockedProxy
		{
			Type = ToggleProxy
			ComponentID = IsNonOverclocked
		}

		CommandConsumptionToggle
		{
			Type = MultiToggle
			Toggles = [PowerToggle, ScorchedToggle]
			Mode = All
		}

		PowerToggle
		{
			Type = UIToggle
			ToggleID = "on_off"
			Default = 1
			RequiresCommand = false
		}

		ScorchedToggle
		{
			Type = StatusToggle
			StatusType = cosmoteer.scorched
			MinStatusValue = 1
			Invert = true
		}

		CommandConsumer
		{
			Type = CommandConsumer
			OperationalToggle = CommandConsumptionToggle
			CommandPoints = 4
		}

		// Starts Normal Batteries

		BatteryStorage  // Used for Drain effects
		{
			Type = MultiResourceStorage
			ResourceType = battery
			ResourceStorages = [InnerFrontBatteryStorage, InnerRightBatteryStorage, InnerBackBatteryStorage, InnerLeftBatteryStorage, ModularBatteryStorage]
			ReceiveResourceMediaEffects = &/COMMON_EFFECTS/PowerDeliver
			AddMode = PrioritizeLeastResources
			RemoveMode = DistributeProportionallyByAvailable
			ToggleOnResources = 7001
			DrainResistance
			{
				BaseValue = 0
				Modifiers
				[
					{
						Type = Status
						StatusType = cosmoteer.shield_overload
						ModificationMode = Subtract
					}
				]
			}
		}

		CombinedBatteryStorage
		{
			Type = MultiResourceStorage
			ResourceType = battery
			ResourceStorages = [InnerFrontBatteryStorage, InnerRightBatteryStorage, InnerBackBatteryStorage, InnerLeftBatteryStorage]
			ReceiveResourceMediaEffects = &/COMMON_EFFECTS/PowerDeliver
			AddMode = PrioritizeLeastResources // DistributeProportionallyByAvailable
		}
		BatteryConsumer
		{
			Type = ResourceConsumer
			ResourceType = battery
			Storage = CombinedBatteryStorage
			DefaultPriority = &/PRIORITIES/Defense_Supply
			ResupplyThreshold = 500
			OperationalToggle = PowerToggle
		}
		
		BatteryConsumer2 : BatteryConsumer	{ Storage = ModularBatteryStorage }	// If I use ModularCombinedBatteryStorage so that all batteries (including ModularBatteryStorage) are in the same consumer, the ModularBatteryStorage never receives energy, no idea why.
		
		
		ProgressBarSegments
		{
			Type = ProgressBar
			OperationalToggle = IsOperational
			ShowProgressFor = CombinedBatteryStorage
			LowColor = [0, 0, 255]
			HighColor = [0, 0, 255]
			FullColor = [0, 0, 255]
			Height = 10
		}
		
		// Inner
		
		InnerFrontIsOperational
		{
			Type = MultiToggle
			Toggles = [PowerToggle, InnerFrontBatteryStorage, ScorchedToggle, IsOperational]
			Mode = All
		}
		InnerFrontOverclockEffect :			InnerFrontIsOperational	{ Toggles = [InnerFrontIsOperational, OverclockedEffectToggle] }
		InnerFrontOverloadEffect :			InnerFrontIsOperational	{ Toggles = [InnerFrontIsOperational, IsOperationalOverloaded] }
		InnerFrontOverclockOverloadEffect :	InnerFrontIsOperational	{ Toggles = [InnerFrontIsOperational, IsOperationalOverclockedOverloaded] }
		InnerFrontBatteryStorage
		{
			Type = ResourceStorage
			ResourceType = battery
			MaxResources = 2000
			ToggleOnResources = 2000
			DrainOnFtlJump = true
			ReceiveResourceMediaEffects = &/COMMON_EFFECTS/PowerDeliver
		}
		CombinedInnerFrontBatteryStorage
		{
			Type = MultiResourceStorage
			ResourceType = battery
			IsDrainable = true
			OperationalToggle = IsOverclocked
			ResourceStorages = [InnerFrontBatteryStorage, ModularInnerBatteryStorageProxy]
			ReceiveResourceMediaEffects = &/COMMON_EFFECTS/PowerDeliver
			RemoveMode = PrioritizeMostResources // DistributeProportionallyByAvailable
		}
		InnerFrontPowerDrain
		{
			Type = ResourceConverter
			OperationalToggle = InnerFrontIsOperational
			FromStorage = InnerFrontBatteryStorage
			FromQuantity = 38
			MinFromQuantityForConversion = 1
			Interval = 1
		}
		
		InnerRightIsOperational : 			InnerFrontIsOperational				{ Toggles = [PowerToggle, InnerRightBatteryStorage, ScorchedToggle, IsOperational] }
		InnerRightOverloadEffect :			InnerFrontIsOperational				{ Toggles = [InnerRightIsOperational, IsOperationalOverloaded] }
		InnerRightOverclockEffect :			InnerFrontIsOperational				{ Toggles = [InnerRightIsOperational, OverclockedEffectToggle] }
		InnerRightOverclockOverloadEffect :	InnerFrontIsOperational				{ Toggles = [InnerRightIsOperational, IsOperationalOverclockedOverloaded] }
		InnerRightBatteryStorage : 			InnerFrontBatteryStorage			{}
		CombinedInnerRightBatteryStorage :	CombinedInnerFrontBatteryStorage	{ ResourceStorages = [InnerRightBatteryStorage, ModularInnerBatteryStorageProxy] }
		InnerRightPowerDrain : 				InnerFrontPowerDrain
		{
			OperationalToggle = InnerRightIsOperational
			FromStorage = InnerRightBatteryStorage
		}
		
		InnerBackIsOperational : 			InnerFrontIsOperational				{ Toggles = [PowerToggle, InnerBackBatteryStorage, ScorchedToggle, IsOperational] }
		InnerBackOverloadEffect :			InnerFrontIsOperational				{ Toggles = [InnerBackIsOperational, IsOperationalOverloaded] }
		InnerBackOverclockEffect :			InnerFrontIsOperational				{ Toggles = [InnerBackIsOperational, OverclockedEffectToggle] }
		InnerBackOverclockOverloadEffect :	InnerFrontIsOperational				{ Toggles = [InnerBackIsOperational, IsOperationalOverclockedOverloaded] }
		InnerBackBatteryStorage : 			InnerFrontBatteryStorage			{}
		CombinedInnerBackBatteryStorage :	CombinedInnerFrontBatteryStorage	{ ResourceStorages = [InnerBackBatteryStorage, ModularInnerBatteryStorageProxy] }
		InnerBackPowerDrain : 				InnerFrontPowerDrain
		{
			OperationalToggle = InnerBackIsOperational
			FromStorage = InnerBackBatteryStorage
		}
		
		InnerLeftIsOperational : 			InnerFrontIsOperational				{ Toggles = [PowerToggle, InnerLeftBatteryStorage, ScorchedToggle, IsOperational] }
		InnerLeftOverloadEffect :			InnerFrontIsOperational				{ Toggles = [InnerLeftIsOperational, IsOperationalOverloaded] }
		InnerLeftOverclockEffect :			InnerFrontIsOperational				{ Toggles = [InnerLeftIsOperational, OverclockedEffectToggle] }
		InnerLeftOverclockOverloadEffect :	InnerFrontIsOperational				{ Toggles = [InnerLeftIsOperational, IsOperationalOverclockedOverloaded] }
		InnerLeftBatteryStorage : 			InnerFrontBatteryStorage			{}
		CombinedInnerLeftBatteryStorage :	CombinedInnerFrontBatteryStorage	{ ResourceStorages = [InnerLeftBatteryStorage, ModularInnerBatteryStorageProxy] }
		InnerLeftPowerDrain : 				InnerFrontPowerDrain
		{
			OperationalToggle = InnerLeftIsOperational
			FromStorage = InnerLeftBatteryStorage
		}
		
		// Ends Normal Batteries

		// Start Modular Battery

		BuffProviderTop
		{
			Type = AreaBuffProvider
			BuffType = BubbleCapacity
			BuffArea = [0, -1, 2, 1]
			OperationalToggle = IsOperational
			Criteria
			{
				Left = 0
				Right = 2
			}
		}
		BuffProviderRight : BuffProviderTop
		{
			BuffArea = [2, 0, 1, 2]
			Criteria
			{
				Rot = 1
				Left = 2
				Right = 3
				Bottom = 2 // With this it also worked
			}
		}
		BuffProviderBottom : BuffProviderTop
		{
			BuffArea = [0, 2, 2, 1]
			Criteria
			{
				Rot = 2
				Right = 2
				Bottom = 3
			}
		}
		BuffProviderLeft : BuffProviderTop
		{
			BuffArea = [-1, 0, 1, 2]
			Criteria
			{
				Rot = 3
				Right = 0
				Bottom = 2
			}
		}

		IsModularToggle
		{
			Type = BuffToggle
			BuffType = BubbleResistanceBonus
		}
		
		IsOperational_Modular_NotOverclocked
		{
			Type = MultiToggle
			Toggles = [IsOperational, IsModularToggle, {Toggle = OverclockedEffectToggle, Invert = true} ]
			Mode = All
		}
		IsOperational_Modular_Overclocked
		{
			Type = MultiToggle
			Toggles = [IsOperational, IsModularToggle, OverclockedEffectToggle]
			Mode = All
		}
		
		CentralBatteryStorage	// I think that using this makes the modular battery less bugged
		{
			Type = ResourceStorage
			ResourceType = battery
			MaxResources = 0
			DrainOnFtlJump = true
			ReceiveResourceMediaEffects = &/COMMON_EFFECTS/PowerDeliver
		}
		
		// Modular
		
		ModularBatteryStorage	// Only for battery consumer and recharge, so that it priorizes the part with least resource instead of the battery with least resource
		{
			Type = MultiResourceStorage
			OperationalToggle = IsOperational
			ResourceType = battery
			ToggleOnResources = 0
			IsDrainable = true
			ResourceStorages = [CentralBatteryStorage]
			ViaBuffs
			{
				OutgoingBuffProviders = [BuffProviderTop, BuffProviderRight, BuffProviderLeft, BuffProviderBottom]
				ComponentID = BatteryStorageProxy
			}
			AddMode = PrioritizeLeastResources
			RemoveMode = PrioritizeLeastResources
			ReceiveResourceMediaEffects = &/COMMON_EFFECTS/PowerDeliver
		}	

		// Outer (when overclocked)
		ModularOuterBatteryStorage : ModularBatteryStorage
		{
			OperationalToggle = IsOperationalOverclocked
			ViaBuffs : ^/0/ViaBuffs { ComponentID = OuterBatteryStorageProxy }
		}
		ModularOuterBatteryStorageProxy
		{
			Type = ResourceStorageProxy
			ResourceType = battery
			ComponentID = ModularOuterBatteryStorage
			OperationalToggle = IsOperationalNonOverclocked
		}
		
		// Inner
		ModularInnerBatteryStorage : ModularBatteryStorage
		{
			ViaBuffs : ^/0/ViaBuffs	{ ComponentID = InnerBatteryStorageProxy }
		}
		ModularInnerBatteryStorageProxy
		{
			Type = MultiResourceStorage
			OperationalToggle = IsOperational
			ResourceType = battery
			ToggleOnResources = 0
			IsDrainable = true
			ResourceStorages = [ModularOuterBatteryStorageProxy, ModularInnerBatteryStorage]
			AddMode = PrioritizeLeastResources
			RemoveMode = PrioritizeLeastResources
			ReceiveResourceMediaEffects = &/COMMON_EFFECTS/PowerDeliver
		}
		
		// Ends Modular Batteries
		
		IsOperationalProxy
		{
			Type = MultiToggle
			Toggles = [ProxyBatteryStorage]
			Mode = All
		}
		
		ProxyBatteryStorage
		{
			Type = ResourceStorage
			ResourceType = battery
			MaxResources = 0
			ToggleOnResources = 1
			DrainOnFtlJump = true
			ReceiveResourceMediaEffects = &/COMMON_EFFECTS/PowerDeliver
		}
		
		// Starts Rotation
		
		IsOperationalTriggerOn
		{
			Type = ToggleTrigger
			Toggle = OverclockedEffectToggle
			TriggerWhenOn = true
			TriggerWhenOff = false
		}
		IsOperationalTriggerOff :	IsOperationalTriggerOn
		{
			TriggerWhenOn = false
			TriggerWhenOff = true
		}
		
		ResetTrigger :	IsOperationalTriggerOn
		{
			Toggle = IsOperationalNonOverclocked
			TriggerWhenOn = false
			TriggerWhenOff = true
		}
		
		RotationTimer
		{
			Type = Timer
			Duration = 60 / 60
			Repeats = true
			StartTrigger = IsOperationalTriggerOn
			StopTrigger = IsOperationalTriggerOff
			StartExpired = true
		}
		
		RotationModes
		{
			Type = ModeCycle
			IncrementTrigger = RotationTimer
			DecrementTrigger = RotationShutDown
			ModeRange = [0, 59]
			StartingMode = 0
			Clamp = false
		}
		Rotation0
		{
			Type = ModeToggle
			Mode = RotationModes
			OnModes = [0]
		}
		Rotation1 :		Rotation0	{ OnModes = [1] }
		Rotation2 :		Rotation0	{ OnModes = [2] }
		Rotation3 :		Rotation0	{ OnModes = [3] }
		Rotation4 :		Rotation0	{ OnModes = [4] }
		Rotation5 :		Rotation0	{ OnModes = [5] }
		Rotation6 :		Rotation0	{ OnModes = [6] }
		Rotation7 :		Rotation0	{ OnModes = [7] }
		Rotation8 :		Rotation0	{ OnModes = [8] }
		Rotation9 :		Rotation0	{ OnModes = [9] }
		Rotation10 :	Rotation0	{ OnModes = [10] }
		Rotation11 :	Rotation0	{ OnModes = [11] }
		Rotation12 :	Rotation0	{ OnModes = [12] }
		Rotation13 :	Rotation0	{ OnModes = [13] }
		Rotation14 :	Rotation0	{ OnModes = [14] }
		Rotation15 :	Rotation0	{ OnModes = [15] }
		Rotation16 :	Rotation0	{ OnModes = [16] }
		Rotation17 :	Rotation0	{ OnModes = [17] }
		Rotation18 :	Rotation0	{ OnModes = [18] }
		Rotation19 :	Rotation0	{ OnModes = [19] }
		Rotation20 :	Rotation0	{ OnModes = [20] }
		Rotation21 :	Rotation0	{ OnModes = [21] }
		Rotation22 :	Rotation0	{ OnModes = [22] }
		Rotation23 :	Rotation0	{ OnModes = [23] }
		Rotation24 :	Rotation0	{ OnModes = [24] }
		Rotation25 :	Rotation0	{ OnModes = [25] }
		Rotation26 :	Rotation0	{ OnModes = [26] }
		Rotation27 :	Rotation0	{ OnModes = [27] }
		Rotation28 :	Rotation0	{ OnModes = [28] }
		Rotation29 :	Rotation0	{ OnModes = [29] }
		Rotation30 :	Rotation0	{ OnModes = [30] }
		Rotation31 :	Rotation0	{ OnModes = [31] }
		Rotation32 :	Rotation0	{ OnModes = [32] }
		Rotation33 :	Rotation0	{ OnModes = [33] }
		Rotation34 :	Rotation0	{ OnModes = [34] }
		Rotation35 :	Rotation0	{ OnModes = [35] }
		Rotation36 :	Rotation0	{ OnModes = [36] }
		Rotation37 :	Rotation0	{ OnModes = [37] }
		Rotation38 :	Rotation0	{ OnModes = [38] }
		Rotation39 :	Rotation0	{ OnModes = [39] }
		Rotation40 :	Rotation0	{ OnModes = [40] }
		Rotation41 :	Rotation0	{ OnModes = [41] }
		Rotation42 :	Rotation0	{ OnModes = [42] }
		Rotation43 :	Rotation0	{ OnModes = [43] }
		Rotation44 :	Rotation0	{ OnModes = [44] }
		Rotation45 :	Rotation0	{ OnModes = [45] }
		Rotation46 :	Rotation0	{ OnModes = [46] }
		Rotation47 :	Rotation0	{ OnModes = [47] }
		Rotation48 :	Rotation0	{ OnModes = [48] }
		Rotation49 :	Rotation0	{ OnModes = [49] }
		Rotation50 :	Rotation0	{ OnModes = [50] }
		Rotation51 :	Rotation0	{ OnModes = [51] }
		Rotation52 :	Rotation0	{ OnModes = [52] }
		Rotation53 :	Rotation0	{ OnModes = [53] }
		Rotation54 :	Rotation0	{ OnModes = [54] }
		Rotation55 :	Rotation0	{ OnModes = [55] }
		Rotation56 :	Rotation0	{ OnModes = [56] }
		Rotation57 :	Rotation0	{ OnModes = [57] }
		Rotation58 :	Rotation0	{ OnModes = [58] }
		Rotation59 :	Rotation0	{ OnModes = [59] }
		
		// Finish Rotation
		
		IsNotOverclocked
		{
			Type = MultiToggle
			Toggles = [OverclockedEffectToggle]
			Invert = true
			Mode = All
		}
		
		RotationShutDown
		{
			Type = MultiTrigger
			Triggers = [Rotation0ShutDown, Rotation1ShutDown, Rotation2ShutDown, Rotation3ShutDown, Rotation4ShutDown, Rotation5ShutDown, Rotation6ShutDown, Rotation7ShutDown, Rotation8ShutDown, Rotation9ShutDown,
			Rotation10ShutDown, Rotation11ShutDown, Rotation12ShutDown, Rotation13ShutDown, Rotation14ShutDown, Rotation15ShutDown, Rotation16ShutDown, Rotation17ShutDown, Rotation18ShutDown, Rotation19ShutDown,
			Rotation20ShutDown, Rotation21ShutDown, Rotation22ShutDown, Rotation23ShutDown, Rotation24ShutDown, Rotation25ShutDown, Rotation26ShutDown, Rotation27ShutDown, Rotation28ShutDown, Rotation29ShutDown,
			Rotation30ShutDown, Rotation31ShutDown, Rotation32ShutDown, Rotation33ShutDown, Rotation34ShutDown, Rotation35ShutDown, Rotation36ShutDown, Rotation37ShutDown, Rotation38ShutDown, Rotation39ShutDown,
			Rotation40ShutDown, Rotation41ShutDown, Rotation42ShutDown, Rotation43ShutDown, Rotation44ShutDown, Rotation45ShutDown, Rotation46ShutDown, Rotation47ShutDown, Rotation48ShutDown, Rotation49ShutDown,
			Rotation50ShutDown, Rotation51ShutDown, Rotation52ShutDown, Rotation53ShutDown, Rotation54ShutDown, Rotation55ShutDown, Rotation56ShutDown, Rotation57ShutDown, Rotation58ShutDown, Rotation59ShutDown]
		}
		RotationShutDownStarter
		{
			Type = MultiToggle
			Toggles = [ IsOperationalNonOverclocked, { Toggle=Rotation0; Invert=true } ]
			Mode = All
		}
		Rotation0ShutDown
		{
			Type = ToggleTrigger
			Toggle = RotationShutDownStarter
			TriggerWhenOn = true
			TriggerWhenOff = false
		}
		Rotation1ShutDown :		Rotation0ShutDown
		{
			Toggle = Rotation1
			OperationalToggle = IsNotOverclocked
		}
		Rotation2ShutDown :		Rotation1ShutDown	{ Toggle = Rotation2 }
		Rotation3ShutDown :		Rotation1ShutDown	{ Toggle = Rotation3 }
		Rotation4ShutDown :		Rotation1ShutDown	{ Toggle = Rotation4 }
		Rotation5ShutDown :		Rotation1ShutDown	{ Toggle = Rotation5 }
		Rotation6ShutDown :		Rotation1ShutDown	{ Toggle = Rotation6 }
		Rotation7ShutDown :		Rotation1ShutDown	{ Toggle = Rotation7 }
		Rotation8ShutDown :		Rotation1ShutDown	{ Toggle = Rotation8 }
		Rotation9ShutDown :		Rotation1ShutDown	{ Toggle = Rotation9 }
		Rotation10ShutDown :	Rotation1ShutDown	{ Toggle = Rotation10 }
		Rotation11ShutDown :	Rotation1ShutDown	{ Toggle = Rotation11 }
		Rotation12ShutDown :	Rotation1ShutDown	{ Toggle = Rotation12 }
		Rotation13ShutDown :	Rotation1ShutDown	{ Toggle = Rotation13 }
		Rotation14ShutDown :	Rotation1ShutDown	{ Toggle = Rotation14 }
		Rotation15ShutDown :	Rotation1ShutDown	{ Toggle = Rotation15 }
		Rotation16ShutDown :	Rotation1ShutDown	{ Toggle = Rotation16 }
		Rotation17ShutDown :	Rotation1ShutDown	{ Toggle = Rotation17 }
		Rotation18ShutDown :	Rotation1ShutDown	{ Toggle = Rotation18 }
		Rotation19ShutDown :	Rotation1ShutDown	{ Toggle = Rotation19 }
		Rotation20ShutDown :	Rotation1ShutDown	{ Toggle = Rotation20 }
		Rotation21ShutDown :	Rotation1ShutDown	{ Toggle = Rotation21 }
		Rotation22ShutDown :	Rotation1ShutDown	{ Toggle = Rotation22 }
		Rotation23ShutDown :	Rotation1ShutDown	{ Toggle = Rotation23 }
		Rotation24ShutDown :	Rotation1ShutDown	{ Toggle = Rotation24 }
		Rotation25ShutDown :	Rotation1ShutDown	{ Toggle = Rotation25 }
		Rotation26ShutDown :	Rotation1ShutDown	{ Toggle = Rotation26 }
		Rotation27ShutDown :	Rotation1ShutDown	{ Toggle = Rotation27 }
		Rotation28ShutDown :	Rotation1ShutDown	{ Toggle = Rotation28 }
		Rotation29ShutDown :	Rotation1ShutDown	{ Toggle = Rotation29 }
		Rotation30ShutDown :	Rotation1ShutDown	{ Toggle = Rotation30 }
		Rotation31ShutDown :	Rotation1ShutDown	{ Toggle = Rotation31 }
		Rotation32ShutDown :	Rotation1ShutDown	{ Toggle = Rotation32 }
		Rotation33ShutDown :	Rotation1ShutDown	{ Toggle = Rotation33 }
		Rotation34ShutDown :	Rotation1ShutDown	{ Toggle = Rotation34 }
		Rotation35ShutDown :	Rotation1ShutDown	{ Toggle = Rotation35 }
		Rotation36ShutDown :	Rotation1ShutDown	{ Toggle = Rotation36 }
		Rotation37ShutDown :	Rotation1ShutDown	{ Toggle = Rotation37 }
		Rotation38ShutDown :	Rotation1ShutDown	{ Toggle = Rotation38 }
		Rotation39ShutDown :	Rotation1ShutDown	{ Toggle = Rotation39 }
		Rotation40ShutDown :	Rotation1ShutDown	{ Toggle = Rotation40 }
		Rotation41ShutDown :	Rotation1ShutDown	{ Toggle = Rotation41 }
		Rotation42ShutDown :	Rotation1ShutDown	{ Toggle = Rotation42 }
		Rotation43ShutDown :	Rotation1ShutDown	{ Toggle = Rotation43 }
		Rotation44ShutDown :	Rotation1ShutDown	{ Toggle = Rotation44 }
		Rotation45ShutDown :	Rotation1ShutDown	{ Toggle = Rotation45 }
		Rotation46ShutDown :	Rotation1ShutDown	{ Toggle = Rotation46 }
		Rotation47ShutDown :	Rotation1ShutDown	{ Toggle = Rotation47 }
		Rotation48ShutDown :	Rotation1ShutDown	{ Toggle = Rotation48 }
		Rotation49ShutDown :	Rotation1ShutDown	{ Toggle = Rotation49 }
		Rotation50ShutDown :	Rotation1ShutDown	{ Toggle = Rotation50 }
		Rotation51ShutDown :	Rotation1ShutDown	{ Toggle = Rotation51 }
		Rotation52ShutDown :	Rotation1ShutDown	{ Toggle = Rotation52 }
		Rotation53ShutDown :	Rotation1ShutDown	{ Toggle = Rotation53 }
		Rotation54ShutDown :	Rotation1ShutDown	{ Toggle = Rotation54 }
		Rotation55ShutDown :	Rotation1ShutDown	{ Toggle = Rotation55 }
		Rotation56ShutDown :	Rotation1ShutDown	{ Toggle = Rotation56 }
		Rotation57ShutDown :	Rotation1ShutDown	{ Toggle = Rotation57 }
		Rotation58ShutDown :	Rotation1ShutDown	{ Toggle = Rotation58 }
		Rotation59ShutDown :	Rotation1ShutDown	{ Toggle = Rotation59 }		

/*	
		// Alternative RotationShutDown
		
		Rotation1Off
		{
			Type = MultiToggle
			Toggles = [Rotation1, IsOperationalNonOverclocked]
			Mode = All
		}
		Rotation2Off : Rotation1Off	{ Toggles = [Rotation2, IsOperationalNonOverclocked] }
		Rotation3Off : Rotation1Off	{ Toggles = [Rotation3, IsOperationalNonOverclocked] }
		Rotation4Off : Rotation1Off	{ Toggles = [Rotation4, IsOperationalNonOverclocked] }
		Rotation5Off : Rotation1Off	{ Toggles = [Rotation5, IsOperationalNonOverclocked] }
		Rotation6Off : Rotation1Off	{ Toggles = [Rotation6, IsOperationalNonOverclocked] }
		Rotation7Off : Rotation1Off	{ Toggles = [Rotation7, IsOperationalNonOverclocked] }
		Rotation8Off : Rotation1Off	{ Toggles = [Rotation8, IsOperationalNonOverclocked] }
		Rotation9Off : Rotation1Off	{ Toggles = [Rotation9, IsOperationalNonOverclocked] }
		
		Rotation1ShutDown
		{
			Type = ToggleTrigger
			Toggle = Rotation1Off
			TriggerWhenOn = true
			TriggerWhenOff = false
		}
		Rotation2ShutDown : Rotation1ShutDown	{ Toggle = Rotation2Off }
		Rotation3ShutDown : Rotation1ShutDown	{ Toggle = Rotation3Off }
		Rotation4ShutDown : Rotation1ShutDown	{ Toggle = Rotation4Off }
		Rotation5ShutDown : Rotation1ShutDown	{ Toggle = Rotation5Off }
		Rotation6ShutDown : Rotation1ShutDown	{ Toggle = Rotation6Off }
		Rotation7ShutDown : Rotation1ShutDown	{ Toggle = Rotation7Off }
		Rotation8ShutDown : Rotation1ShutDown	{ Toggle = Rotation8Off }
		Rotation9ShutDown : Rotation1ShutDown	{ Toggle = Rotation9Off }
*/


/*		// Alternative Rotation System

		RotationTimerAccumulator
		{
			Type = ValueAccumulator
			AccumulatingToggle = IsOperational
			BaseValue = 0
			AccumulationRate = 8 / 120
			NonOperationalBehaviour = 2
			MaxValue = 8 // +1 cause at 8 it resets to 0
			AccumulationTriggers
			[
				{
					Trigger = RotationCap
					Value = 0
					Operation = 2
				}
			]
		}

		RotationCap
		{
			Type = ThresholdTrigger
			AmountFrom = RotationTimerAccumulator
			MinAmount = 8
		}
*/

/*
TMP_ValueTween
{
	Type = ValueTween
	OnTweenDuration = 10
	OffTweenDuration = 10
	IsOnToggle = IsOperational
}

TMP_TransformLerp
{
	Type = TransformLerp
	ValueFrom = TMP_ValueTween
	StartRotation = -90d
	EndRotation = 90d
}

ArcShieldTMP0
{
	Type = ArcShield
	Radius = 10
//	Rotation = -90d
	ChainedTo = TMP_TransformLerp
	OperationalToggle = IsOperational
	DrainResourcesFrom	= BatteryStorage
	ResourceDrainPerDamage = 0.4
	Arc = 90d
	PenetrationResistance = [10, 10]
	Location = [1, 1]
	ShieldMediaEffects : <./Data/ships/terran/shield_gen_small/shield_gen_small.rules>/Part/Components/ArcShield/ShieldMediaEffects	[]
}
*/

/*	// Crashes when closing the game
TMP_ValueTween
{
	Type = ValueTween
	OnTweenDuration = 10
	OffTweenDuration = 10
	IsOnToggle = IsOperational
}

TMP_ValueAccumulator0
{
	Type = ValueAccumulator
	AccumulatingToggle = IsOperational // TMP_Mode0Toggle
	BaseValue = 0.025
//	AccumulationRate = 10d
	NonOperationalBehaviour = 0
	AccumulationTriggers
	[
		{
			Trigger = TMP_Timer
			Value = 0.025
	//		Operation = 1
			AllowWhenOff = false
		}
	]
}
TMP_ValueAccumulator1 : TMP_ValueAccumulator0
{
	AccumulatingToggle = IsOperational // TMP_Mode1Toggle
	BaseValue = 0
}


Proxy0Toggle
{
	Type = ToggleProxy
	ComponentID = TMP_Mode0Toggle
}
Proxy1Toggle :	Proxy0Toggle	{ ComponentID = TMP_Mode1Toggle }


Proxy0
{
	Type = ChainableProxy
	ProxyToggle = Proxy0Toggle
	ComponentID = TMP_TransformLerp0
}
Proxy1 :	Proxy0	{ ProxyToggle = Proxy1Toggle }

TMP_TransformLerp0
{
	Type = TransformLerp
	ValueFrom = TMP_ValueAccumulator0
	StartRotation = -90d
	EndRotation = 90d
}
TMP_TransformLerp1 :	TMP_TransformLerp0	{ ValueFrom = TMP_ValueAccumulator1 }


TMP_Timer
{
	Type = Timer
	Duration = 0.5
	Repeats = true
	AutoStart = true
}

TMP_Modes
{
	Type = ModeCycle
	IncrementTrigger = TMP_Timer
	ModeRange = [0, 1]
	StartingMode = 0
	Clamp = false
}

TMP_Mode0
{
	Type = ModeToggle
	Mode = TMP_Modes
	OnModes = [0]
}
TMP_Mode1 :	TMP_Mode0	{ OnModes = [1] }


TMP_Mode0Toggle
{
	Type = MultiToggle
	Toggles = [ IsOperational, TMP_Mode0 ]
	Mode = All
}
TMP_Mode1Toggle :	TMP_Mode0Toggle	{ Toggles = [ IsOperational, TMP_Mode1 ] }

ArcShieldTMP0
{
	Type = ArcShield
	Radius = 10
//	Rotation = -90d
	ChainedTo = Proxy0
	OperationalToggle = TMP_Mode0Toggle
	DrainResourcesFrom	= BatteryStorage
	ResourceDrainPerDamage = 0.4
	Arc = 90d
	PenetrationResistance = [10, 10]
	Location = [1, 1]
	ShieldMediaEffects : <./Data/ships/terran/shield_gen_small/shield_gen_small.rules>/Part/Components/ArcShield/ShieldMediaEffects	[]
}
ArcShieldTMP1 : ArcShieldTMP0
{
	ChainedTo = Proxy1
	OperationalToggle = TMP_Mode1Toggle
}

*/


		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// ARCSHIELD ORIGINAL - START //////////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		ArcShield : <./Data/ships/terran/shield_gen_small/shield_gen_small.rules>/Part/Components/ArcShield
		{
			Radius
			{
				BaseValue = 7
				Modifiers
				[
					{
						Type = BuffRemap
						BuffType = Overclock
						ModificationMode = Multiply
						RemapFrom = [0, 1]
						RemapTo = [1, &~/OVERCLOCK/ARC_RADIUS_FACTOR]
					}
					{
						Type = ScaledBuff
						BuffType = BubbleRadiusBonus
						Scale = 1.5
						ModificationMode = Add
					}
				]
			}
			Arc = 90d
			OperationalToggle = IsOperationalProxy // IsOperational
			PenetrationResistance = [ { BaseValue= 8.33; BuffType=BubbleResistanceBonus; BuffMode=Add; }, 0]
			DrainResourcesFrom = ProxyBatteryStorage
//			BlueprintArcSprite	// So that it doesn't appear
			BlueprintArcSpriteSegments = 64
			ResourceDrainPerDamage	//	Could be removed
			{
				BaseValue = .4
				Modifiers
				[
					{
						Type = Status
						StatusType = cosmoteer.shield_overload
						ModificationMode = Multiply
						BaseStatusValue = 1
					}
				]
			}
			Rotation = -90d
			Location = [1, 1]

			ShieldMediaEffects
			[
				: &../^/0/ShieldMediaEffects/0
				{
					Radius = &~/Part/Components/ArcShield/Radius/
					Arc = &~/Part/Components/ArcShield/Arc
					FadeInTime = 0
					FadeOutTime = 0
					ArcSprite : ^/0/ArcSprite
					{
						_xScale = 1
						Size = [0, 1.5]
					}
				}
				: &../^/0/ShieldMediaEffects/1	{}
			]

		}
		
		ArcShieldRight : ArcShield	{ Rotation = 0d }
		ArcShieldBack : ArcShield	{ Rotation = 90d }
		ArcShieldLeft : ArcShield	{ Rotation = 180d }

		OverclockTweenToggle
		{
			Type = ThresholdToggle
			ValueFrom = OverclockStateValue
			MinAmount = 1
		}
		
		OverclockedEffectToggle
		{
			Type = MultiToggle
			Toggles = [OverclockTweenToggle, IsOperationalOverclocked]
			Mode = All
		}
		
		Overclock_BlueprintArcFront
		{
			Type = ArcSprite
			ChainedTo = ArcShield
			Radius = (&../ArcShield/Radius/BaseValue) * (&~/OVERCLOCK/ARC_RADIUS_FACTOR)
			Arc = 90d // 360d
			SpriteSegments = (&../ArcShield/BlueprintArcSpriteSegments)
			Sprite
			{
				Texture
				{
					File = "./Data/ships/terran/shield_gen_small/shield_energy_oc.png"
					UVMode = Wrap
					SampleMode = Linear
					MipLevels = 1
				}
				Size = [0, 1.5]
				Color = [255, 134, 36, 127]
			}
		}
		
		Overclock_BlueprintArcRight : Overclock_BlueprintArcFront	{ ChainedTo = ArcShieldRight }
		Overclock_BlueprintArcBack : Overclock_BlueprintArcFront	{ ChainedTo = ArcShieldBack }
		Overclock_BlueprintArcLeft : Overclock_BlueprintArcFront	{ ChainedTo = ArcShieldLeft }
		
		OverclockEffect
		{
			Type = ShieldArcsMimic
			Shield = ArcShield
			ChainedTo = ArcShield
			FactorMediaEffectsIntensityWith = BatteryStorage
			MimicFadeInStartTime = false
			OperationalToggle = OverclockedEffectToggle
			ContinuousEffects
			[
				{
					Type = ArcShield
					Radius = &~/Part/Components/ArcShield/Radius
					Arc = &~/Part/Components/ArcShield/Arc
					FadeInTime = .25
					FadeOutTime = .25
					FadeFromScale = 1.025
					ArcSprite
					{
						Texture
						{
							File = "./Data/ships/terran/shield_gen_small/shield_energy_oc.png"
							UVMode = Wrap
							SampleMode = Linear
							MipLevels = 1
						}
						Shader = "shield.shader"
						_waveTex
						{
							File = "./Data/ships/terran/shield_gen_small/shield_energy_wave.png"
							UVMode = Wrap
							SampleMode = Linear
							MipLevels = max
						}
						_maskTex
						{
							File = "./Data/ships/terran/shield_gen_small/shield_mask_oc.png"
							SampleMode = Linear
							MipLevels = 1
						}
						_waveSpeed = 1
						_waveAlpha = 1
						_waveCurveInterval = .5
						_waveCurveMagnitude = .35
						_waveCurveUOffsetPerSecond = .2
						_fullPowerColor1 = [203, 80, 33, 127]
						_lowPowerColor1 = [255, 0, 0, 127]
						_fullPowerColor2 = [255, 134, 36, 255]
						_lowPowerColor2 = [255, 50, 0, 127]
						_lowPowerThicknessExponent = .6
						_xScale = 1
						_hexDamageIntensity = 0.8
						TargetBlendMode = Add
						Size = [0, 1.5]
					}
					ArcSpriteSegments = 64
					Bucket = Lower1
				}
			]
		}
        
		OverloadValue
		{
			Type = BuffableValue
			Value
			{
				BaseValue = 0
				Modifiers
				[
					{
						Type = Status
						StatusType = cosmoteer.shield_overload
						ModificationMode = Replace
						BaseStatusValue = 0
					}
				]
			}
		}
		
		IsOverloaded
		{
			Type = ThresholdToggle
			ValueFrom = OverloadValue
			MinAmount = 0.01
		}
		
		
		IsOperationalOverloaded
		{
			Type = MultiToggle
			Toggles = [ IsOperational, IsOverloaded ]
			Mode = All
		}
		
		IsOperationalOverclockedOverloaded
		{
			Type = MultiToggle
			Toggles = [ IsOperational, IsOverloaded, OverclockedEffectToggle ]
			Mode = All
		}
		
		OverloadEffect
		{
			Type = ShieldArcsMimic
			Shield = ArcShield
			ChainedTo = ArcShield
			FactorMediaEffectsIntensityWith = BatteryStorage
			FactorRedVertexColorWith = OverloadValue
			OperationalToggle = IsOperationalOverloaded
			ContinuousEffects
			[
				{
					Type = ArcShield
					Radius = &~/Part/Components/ArcShield/Radius
					Arc = &~/Part/Components/ArcShield/Arc
					FadeInTime = 0.5
					FadeOutTime = 0.5
					FadeFromScale = .8
					ArcAngleAffectsUVs = true
					UPerNinetyDegrees = 1
					ArcSprite
					{
						Texture
						{
							File = "./Data/ships/terran/shield_gen_small/shield_overload.png"
							UVMode = Wrap
							SampleMode = Linear
							MipLevels = 1
						}
						Shader = "shield_overload.shader"
						_noiseTex1
						{
							File = "./Data/statuses/fire/particles/fire_noise.png"
							UVMode = Wrap
							SampleMode = Linear
							MipLevels = max
						}
						_noiseTex2
						{
							File = "./Data/statuses/fire/particles/fire_noise.png"
							UVMode = Wrap
							SampleMode = Linear
							MipLevels = max
						}
						_baseShieldTex
						{
							File = "./Data/ships/terran/shield_gen_small/shield_mask.png"
							UVMode = Wrap
							SampleMode = Linear
							MipLevels = 1
						}
						_waveSpeed = 1
						_waveAlpha = 1
						_waveCurveInterval = .5
						_waveCurveMagnitude = .35
						_waveCurveUOffsetPerSecond = .2
						
						_color1 = [255, 0, 255 * 0.31, 0]
						_color2 = [255, 255 * 0.41, 0, 0]
						_maxGreen = 0.9
						
						_xScale = 1
						_gradientXWidth = 1.05
						_hexDamageIntensity = 0.8
						TargetBlendMode = Add
						Size = [0, 1.5]
					}
					ArcSpriteSegments = 64
					Bucket = Lower1
				}
			]
		}
		
		OverclockOverloadEffect
		{
			Type = ShieldArcsMimic
			Shield = ArcShield
			ChainedTo = ArcShield
			FactorMediaEffectsIntensityWith = BatteryStorage
			FactorRedVertexColorWith = OverloadValue
			OperationalToggle = IsOperationalOverclockedOverloaded
			ContinuousEffects
			[
				{
					Type = ArcShield
					Radius = &~/Part/Components/ArcShield/Radius
					Arc = &~/Part/Components/ArcShield/Arc
					FadeInTime = .25
					FadeOutTime = .25
					FadeFromScale = 1.025
					ArcSprite
					{
						Texture
						{
							File = "./Data/ships/terran/shield_gen_small/shield_overload_oc.png"
							UVMode = Wrap
							SampleMode = Linear
							MipLevels = 1
						}
						Shader = "./Data/ships/terran/shield_gen_small/shield_overload.shader"
						_noiseTex1
						{
							File = "./Data/statuses/fire/particles/fire_noise.png"
							UVMode = Wrap
							SampleMode = Linear
							MipLevels = max
						}
						_noiseTex2
						{
							File = "./Data/statuses/fire/particles/fire_noise.png"
							UVMode = Wrap
							SampleMode = Linear
							MipLevels = max
						}
						_baseShieldTex
						{
							File = "./Data/ships/terran/shield_gen_small/shield_mask_oc.png"
							UVMode = Wrap
							SampleMode = Linear
							MipLevels = 1
						}
						_waveSpeed = 1
						_waveAlpha = 1
						_waveCurveInterval = .5
						_waveCurveMagnitude = .35
						_waveCurveUOffsetPerSecond = .2
						
						_color1 = [255, 0, 255 * 0.31, 0]
						_color2 = [255, 255 * 0.41, 0, 0]
						_maxGreen = 0.9
						
						_xScale = 1.2
						_hexDamageIntensity = 0.8
						TargetBlendMode = Add
						Size = [0, 1.5]
					}
					ArcSpriteSegments = 64
					Bucket = Lower1
				}
			]
		}

		InnerFrontIsOperationalOverclocked
		{
			Type = MultiToggle
			Toggles = [ InnerFrontIsOperational, IsOperationalOverclocked]
			Mode = Any
		}
		InnerRightIsOperationalOverclocked :	InnerFrontIsOperationalOverclocked	{ Toggles = [ InnerRightIsOperational, IsOperationalOverclocked] }
		InnerBackIsOperationalOverclocked :		InnerFrontIsOperationalOverclocked	{ Toggles = [ InnerBackIsOperational, IsOperationalOverclocked] }
		InnerLeftIsOperationalOverclocked :		InnerFrontIsOperationalOverclocked	{ Toggles = [ InnerLeftIsOperational, IsOperationalOverclocked] }

		// Overclock / Thermal network
		InnerFrontOverclockHeatProducer
		{
			Type = ResourceConverter
			OperationalToggle = InnerFrontIsOperationalOverclocked
			HEAT_PER_INTERVAL = ceil((&~/OVERCLOCK/HEAT_PER_SECOND) * (&Interval))
			ToQuantity = (&HEAT_PER_INTERVAL) * (&~/HEAT_TO_RESOURCE)
			ToStorage = &~/Part/^/0/HEAT_TARGET_STORAGE
			Interval = 0.5
		}
		InnerRightOverclockHeatProducer : InnerFrontOverclockHeatProducer	{ OperationalToggle = InnerRightIsOperationalOverclocked }
		InnerBackOverclockHeatProducer : InnerFrontOverclockHeatProducer	{ OperationalToggle = InnerBackIsOperationalOverclocked }
		InnerLeftOverclockHeatProducer : InnerFrontOverclockHeatProducer	{ OperationalToggle = InnerLeftIsOperationalOverclocked }

		OverclockHitHeatProducer
		{
			Type = ResourceChange
			ResourceStorage = &~/Part/^/0/HEAT_TARGET_STORAGE
			// Provides the post-resistance damage value as EffectScale
			Trigger = Overclock_ArcShieldProxy
			Amount
			{
				BaseValue = "round((&~/OVERCLOCK/HEAT_PER_DAMAGE) * (&~/HEAT_TO_RESOURCE), 0)"
				Modifiers
				[
					{
						Type = EffectScale
						ModificationMode = Multiply
					}
					{
						Type = Status
						StatusType = cosmoteer.shield_overload
						ModificationMode = Multiply
						BaseStatusValue = 1
					}
					{
						Type = Buff
						BuffType = Overclock
						ModificationMode = Multiply
					}
				]
			}
		}
		
		Overclock_ArcShieldProxy
		{
			Type = MultiTrigger
			Triggers = [Overclock_ArcShieldInnerFrontProxy, Overclock_ArcShieldInnerRightProxy, Overclock_ArcShieldInnerBackProxy, Overclock_ArcShieldInnerLeftProxy]
		}
		
		Overclock_ArcShieldInnerFrontProxy
		{
			Type = TriggerProxy
			ComponentID = ArcShield_InnerFront
			ProxyToggle = IsOperationalOverclocked
		}
		Overclock_ArcShieldInnerRightProxy
		{
			Type = TriggerProxy
			ComponentID = ArcShield_InnerRight
			ProxyToggle = IsOperationalOverclocked
		}
		Overclock_ArcShieldInnerBackProxy
		{
			Type = TriggerProxy
			ComponentID = ArcShield_InnerBack
			ProxyToggle = IsOperationalOverclocked
		}
		Overclock_ArcShieldInnerLeftProxy
		{
			Type = TriggerProxy
			ComponentID = ArcShield_Left
			ProxyToggle = IsOperationalOverclocked
		}

		OverheatEffects : ^/0/OverheatEffects
		{
			Location = [1, 1.5]
		}
		
		BubbleHeatCollectionStorage
		{
			Type = ResourceStorageProxy
			ResourceType = heat
			ComponentID = &~/Part/^/0/HEAT_TARGET_STORAGE
//			QuantityScale = 1 / (&~/OVERCLOCK/COLLECTED_HEAT_MULTIPLIER)
		}
		
		Overclock_HeatCollectionBuffProvider
		{
		
			Type = GridBuffProvider
			BuffType = BubbleHeatCollection
			GridDistance = 1
			OperationalToggle = IsOperationalOverclocked
		}
		
		Router
		{
			Type = NetworkRouter
			RouteGenerators
			[
				{
					Type = Simple
					HEAT_INPUT = &~/Part/^/0/HEAT_NETWORK_INPUT
					Routes
					[
						[&../../HEAT_INPUT, Port_TL, 0]
						[&../../HEAT_INPUT, Port_TR, 0]
						[&../../HEAT_INPUT, Port_RT, 0]
						[&../../HEAT_INPUT, Port_RB, 0]
						[&../../HEAT_INPUT, Port_BR, 0]
						[&../../HEAT_INPUT, Port_BL, 0]
						[&../../HEAT_INPUT, Port_LB, 0]
						[&../../HEAT_INPUT, Port_LT, 0]
					]
				}
			]
		}
		Port_TL : ~/Part/^/0/BASE_THERMAL_PORT
		{
			Location = [0, 0]
			Direction = Up
		}
		Port_TR : Port_TL
		{
			Location = [1, 0]
		}
		Port_RT : Port_TL
		{
			Location = [1, 0]
			Direction = Right
		}
		Port_RB : Port_RT
		{
			Location = [1, 1]
		}
		Port_BR : Port_TL
		{
			Location = [1, 1]
			Direction = Down
		}
		Port_BL : Port_BR
		{
			Location = [0, 1]
		}
		Port_LB : Port_TL
		{
			Location = [0, 1]
			Direction = Left
		}
		Port_LT : Port_LB
		{
			Location = [0, 0]
		}

		EmitterEffect
		{
			Type = ContinuousEffects
			ChainedTo = ArcShield
			FactorMediaEffectsIntensityWith = CombinedBatteryStorage
			MaxMediaEffectsZoom = 12
			Location = [1.8, 0]
			OperationalToggle = IsOperationalProxy
			ParentToShip = true
			MediaEffects
			[
				: <./Data/ships/terran/shield_gen_small/shield_gen_small.rules>/Part/Components/EmitterEffect/MediaEffects/0
				{
					Radius = 1.8
					Arc = 360d
				}
				: <./Data/ships/terran/shield_gen_small/shield_gen_small.rules>/Part/Components/EmitterEffect/MediaEffects/1	{}
			]
		}

		ShieldOperationEffects_InnerFront :			<./Data/ships/terran/shield_gen_small/shield_gen_small.rules>/Part/Components/ShieldOperationEffects
		{
			Location = [&~/Part/Components/ArcShield/Radius/BaseValue, 0]
			Toggle = InnerFrontIsOperational
		}
		ShieldOperationEffects_InnerRight :			ShieldOperationEffects_InnerFront	{ Toggle = InnerRightIsOperational }
		ShieldOperationEffects_InnerBack :			ShieldOperationEffects_InnerFront	{ Toggle = InnerBackIsOperational }
		ShieldOperationEffects_InnerLeft :			ShieldOperationEffects_InnerFront	{ Toggle = InnerLeftIsOperational }
		
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// ARCSHIELD ORIGINAL - END ////////////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		Shield_Doodad_Graphics
		{
			Type = Graphics
			Location = [1, 1]
			OperationalToggle = IsOperational
			OperationalDoodad
			{
				Layer = "doodads_high"
				//Offset = [0, 0]
				DamageLevels
				[
					{
						File = "doodad_axe.png"
						NormalsFile = "doodad_axe_normals.png"
						Size = [2, 2]
						RotSpeed = &<../colors.rules>/StatsCommon/DoodadAxe_RotSpeed_0DMG
					}
					{
						File = "doodad_axe_33.png"
						NormalsFile = "doodad_axe_normals_33.png"
						Size = [2, 2]
						RotSpeed = &<../colors.rules>/StatsCommon/DoodadAxe_RotSpeed_33DMG
					}
					{
						File = "doodad_axe_66.png"
						NormalsFile = "doodad_axe_normals_66.png"
						Size = [2, 2]
						RotSpeed = &<../colors.rules>/StatsCommon/DoodadAxe_RotSpeed_66DMG
					}
				]
			}
			NonOperationalDoodad
			{
				Layer = "doodads_high"
				DamageLevels
				[
					{
						File = "doodad_axe.png"
						NormalsFile = "doodad_axe_normals.png"
						Size = [2, 2]
					}
					{
						File = "doodad_axe_33.png"
						NormalsFile = "doodad_axe_normals_33.png"
						Size = [2, 2]
					}
					{
						File = "doodad_axe_66.png"
						NormalsFile = "doodad_axe_normals_66.png"
						Size = [2, 2]
					}
				]
			}
		}

		Graphics
		{
			Type = Graphics
			Location = [1, 1]
			OperationalToggle = IsOperational
			Floor
			{
				Layer = "floors"
				DamageLevels
				[
					{
						File = "floor.png"
						Size = [2, 2]
					}
					{
						File = "floor_33.png"
						Size = [2, 2]
					}
					{
						File = "floor_66.png"
						Size = [2, 2]
					}
				]
			}
			
			Walls
			{
				Layer = "walls"
				DamageLevels
				[
					{
						File = "walls.png"
						Size = [2, 2]
					}
					{
						File = "walls_33.png"
						Size = [2, 2]
					}
					{
						File = "walls_66.png"
						Size = [2, 2]
					}
				]
			}
			
			Roof
			{
				Layer = "roofs"
				DamageLevels
				[
					{
						File = "roof.png"
						NormalsFile = "roof_normals.png"
						Size = [2, 2]
					}
					{
						File = "roof_33.png"
						NormalsFile = "roof_normals_33.png"
						Size = [2, 2]
					}
					{
						File = "roof_66.png"
						NormalsFile = "roof_normals_66.png"
						Size = [2, 2]
					}
				]
			}
		}

		BatterySprites
		{
			Type = ResourceSprites
			Location = [1, 1]
			ResourceStorage = CombinedBatteryStorage
			Layer = "doodads_low"
			ResourceLevels
			[
				{
					File = "batteries1.png"
					Size = [2, 2]
				}
				{
					File = "batteries2.png"
					Size = [2, 2]
				}
				{
					File = "batteries3.png"
					Size = [2, 2]
				}
				{
					File = "batteries4.png"
					Size = [2, 2]
				}
				{
					File = "batteries5.png"
					Size = [2, 2]
				}
				{
					File = "batteries6.png"
					Size = [2, 2]
				}
				{
					File = "batteries7.png"
					Size = [2, 2]
				}
				{
					File = "batteries8.png"
					Size = [2, 2]
				}
			]
		}
				
		OperationEffects
		{
			Type = ToggleEffects
			Toggle = IsOperational
			ToggledOnMediaEffects = &/COMMON_EFFECTS/PowerOn
			ToggledOffMediaEffects = &/COMMON_EFFECTS/PowerOff
		}

		ScorchedTrigger
		{
			Type = ToggleTrigger
			Toggle = ScorchedToggle
			TriggerWhenOn = false
		}

		ScorchedEffects
		{
			Type = TriggeredEffects
			Trigger = ScorchedTrigger
			Location = &../DestroyedEffects/Location
			MediaEffects = &/COMMON_EFFECTS/MedPartScorched
		}

		DestroyedEffects
		{
			Type = DeathEffects
			MediaEffects = &/COMMON_EFFECTS/MedPartDestroyed
			Location = [1, 1]
		}

		Indicators
		{
			Type = IndicatorSprites
			Location = [1, 1]
			Layer = "indicators"
			Indicators
			[
				// Scorched
				{
					Toggle = ScorchedToggle
					AtlasSprite = &/INDICATORS/Scorched
					HidesIndicators = [1,2,3]
				}
				// Turned off.
				{
					Toggle = PowerToggle
					AtlasSprite
					{
						File = &/INDICATORS/PowerOff
						Size = [1, 1]
					}
				}

				// Resetting from overclock
				{
					Toggle = &~/Part/^/0/OVERCLOCK_OPERATIONAL
					AtlasSprite : /INDICATORS/OverclockReset
					{
						Size = [1, 1]
					}
					HidesIndicators = [3]
				}

				// Out of power.
				{
					Toggle = BatteryStorage // ModularCombinedBatteryStorage
					AtlasSprite
					{
						File = &/INDICATORS/NoPower
						Size = [1, 1]
					}
				}
			]
		}

		Blueprints
		{
			Type = BlueprintSprite
			File = "blueprints.png"
			Size = [2, 2]
		}
		
		HeatGenerationValue
		{
			Type = StaticValue
			Value = (&~/OVERCLOCK/HEAT_PER_SECOND)
		}
		HeatGenerationStatProvider
		{
			Type = StatProvider
			Stat = HeatGeneration
			OperationalToggle = OverclockModeToggle
			ValueFrom = HeatGenerationValue
		}
	}

	Stats
	{
		PowerCapacity = (&../StatsByCategory/0/Stats/SegmentCapacity) * (&../StatsByCategory/0/Stats/ShieldSegments)

		RecPower = (&../StatsByCategory/0/Stats/PowerUsageContinuous) + 0.5
		RecCrew = (&RecPower) * 4
	}
	
	StatsByCategory
	[
		{
			NameKey = "StatCategories/ShieldBubbleLarge"
			Stats
			{
				ShieldPenResist = &~/Part/Components/ArcShield/PenetrationResistance/0/BaseValue
				ShieldDist = (&~/Part/Components/ArcShield/Radius/BaseValue) - (&~/Part/Components/ArcShield/Location/1)
				ShieldSegments = 4
				ShieldHPSegment = (&~/Part/Components/InnerFrontBatteryStorage/MaxResources) / (&~/Part/Components/ArcShield/ResourceDrainPerDamage/BaseValue)
				PowerUsageContinuous = (&~/Part/Components/InnerFrontPowerDrain/FromQuantity) / (&~/Part/Components/InnerFrontPowerDrain/Interval) / 1000 * (&ShieldSegments)
				SegmentCapacity = (&~/Part/Components/InnerFrontBatteryStorage/MaxResources) / 1000
			}
		}
	]
	
	SecondaryToolTip
	{
		TitleKey = "StatCategories/Overclocked"
		Stats
		{
//			ShieldHP = (&~/Part/Components/InnerFrontBatteryStorage/MaxResources) / (&~/Part/Components/ArcShield/ResourceDrainPerDamage/BaseValue)
//			ShieldRings = 2
//			ShieldDistRings = (&<stats.rules>/Stats/RadiusOverclocked)
//			ShieldRotationSpeed =
			HeatGeneration = (&~/OVERCLOCK/HEAT_PER_SECOND) * (&~/Part/StatsByCategory/0/Stats/ShieldSegments) // * (&ShieldRings)
			HeatPerDamage = (&~/OVERCLOCK/HEAT_PER_DAMAGE)
		}
	}
	
	StatsNotesKey = "Stats/BubbleNotes"
}